int Resolve_ours(void *repo)
{
	int nStatus = -1;
	if(!repo) return nStatus;

	git_index* index = NULL;
	const git_index_entry* ancestor_out = NULL;
	const git_index_entry* our_out = NULL;
	const git_index_entry* their_out = NULL;
	git_index_entry new_entry;
	git_index_conflict_iterator* conflict_iterator = NULL;

	do
	{
		nStatus = git_repository_index(&index, (git_repository *)repo);
		if(nStatus < 0)
		{
			break;
		}

		if (git_index_has_conflicts(index))
		{
			nStatus = git_index_conflict_iterator_new(&conflict_iterator, index);
			if(nStatus < 0) 
			{
				break;
			}
			git_checkout_options opt = GIT_CHECKOUT_OPTIONS_INIT;
			opt.checkout_strategy |= GIT_CHECKOUT_USE_OURS;  // GIT_CHECKOUT_SAFE  GIT_CHECKOUT_USE_THEIRS
			nStatus = git_checkout_index((git_repository *)repo, index, &opt);
			if(nStatus < 0)
			{
				break;
			}

			new_entry.mode = GIT_FILEMODE_BLOB;
			while (git_index_conflict_next(&ancestor_out, &our_out, &their_out, conflict_iterator) != GIT_ITEROVER)
			{
				new_entry.path = their_out->path;
				nStatus = git_index_conflict_remove(index,their_out->path);
				if(nStatus < 0)
				{
					break;
				}
				//nStatus = git_index_add(index,their_out);
			} 
			const char *content = "hey there\n";
			git_index_add_frombuffer(index, &new_entry, NULL, strlen(content));
		}
		nStatus = git_index_write(index);
		if(nStatus < 0)
		{
			break;
		}

	}while(0);

	git_index_conflict_iterator_free(conflict_iterator);
	git_index_free(index);
	return nStatus;
}